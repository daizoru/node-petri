// Generated by CoffeeScript 1.4.0
(function() {
  var Database, cluster, repeat, timmy, wait, _ref;

  cluster = require('cluster');

  _ref = require('ragtime'), repeat = _ref.repeat, wait = _ref.wait;

  timmy = require('timmy');

  Database = require('./database');

  module.exports = function(options) {
    var db, db_size, nb_cores, restart_delay, runWorker, sampling_delay, sendGenome, _i, _ref1, _ref2, _ref3, _results;
    if (options == null) {
      options = {};
    }
    console.log("master started");
    db_size = (_ref1 = options.db_size) != null ? _ref1 : 10;
    nb_cores = (_ref2 = options.nb_cores) != null ? _ref2 : 1;
    sampling_delay = (_ref3 = options.sampling_delay) != null ? _ref3 : 2..sec;
    restart_delay = 500..ms;
    db = new Database(db_size);
    sendGenome = function(worker) {
      var genome;
      genome = db.next();
      if (genome != null) {
        console.log("sending genome");
        worker.genome = genome;
        return worker.send(JSON.stringify({
          genome: genome
        }));
      } else {
        console.log("error, no genome to send; retrying later");
        return wait(restart_delay)(function() {
          return sendGenome(worker);
        });
      }
    };
    runWorker = function() {
      var worker;
      console.log("runWorker");
      worker = cluster.fork();
      return worker.on('message', function(msg) {
        console.log("worker replied");
        msg = JSON.parse(msg);
        if ('hello' in msg) {
          sendGenome(worker);
        }
        if ('record' in msg) {
          db.record(msg.record);
        }
        if ('die' in msg) {
          db.remove(worker.genome);
        }
        if ('die' in msg) {
          return console.log("worker died: " + msg.die);
        }
      });
    };
    cluster.on("exit", function(worker, code, signal) {
      console.log("worker exited: " + code);
      return wait(restart_delay)(function() {
        return runWorker();
      });
    });
    console.log("nb_cores: " + nb_cores);
    (function() {
      _results = [];
      for (var _i = 0; 0 <= nb_cores ? _i <= nb_cores : _i >= nb_cores; 0 <= nb_cores ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(function(i) {
      return runWorker();
    });
    repeat(sampling_delay, function() {
      var g;
      g = db.pick();
      if (!g) {
        return;
      }
      console.log("random individual:");
      console.log("  hash:     : " + g.hash);
      console.log("  generation: " + g.generation);
      console.log("   parent stats:");
      console.log("    forking   : " + g.stats.forking_rate);
      console.log("    mutation  : " + g.stats.mutation_rate);
      console.log("    lifespan  : " + g.stats.lifespan_rate + "\n");
      console.log(" general stats:");
      console.log("  db size: " + (db.size()));
      return console.log("  counter: " + db.counter);
    });
    return console.log("  oldest : " + (db.oldestGeneration()) + "\n");
  };

}).call(this);
