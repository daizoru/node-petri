// Generated by CoffeeScript 1.4.0
(function() {
  var Database, isFunction, makeId, pick, repeat, sha1, shuffle, timmy, wait, _ref, _ref1;

  _ref = require('ragtime'), repeat = _ref.repeat, wait = _ref.wait;

  timmy = require('timmy');

  _ref1 = require('../common'), isFunction = _ref1.isFunction, makeId = _ref1.makeId, sha1 = _ref1.sha1, shuffle = _ref1.shuffle, pick = _ref1.pick;

  Database = require('./database');

  module.exports = function(cluster, options) {
    var broadcast, db, db_size, id, nb_cores, restart_delay, runWorker, sampling_delay, sendGenome, _i, _j, _len, _ref2, _ref3, _ref4, _ref5, _results;
    if (options == null) {
      options = {};
    }
    db_size = (_ref2 = options.db_size) != null ? _ref2 : 10;
    nb_cores = (_ref3 = options.nb_cores) != null ? _ref3 : 1;
    sampling_delay = (_ref4 = options.sampling_delay) != null ? _ref4 : 2..sec;
    restart_delay = 50..ms;
    broadcast = function(f) {};
    _ref5 = cluster.workers;
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      id = _ref5[_i];
      f(cluster.workers[id]);
    }
    db = new Database(db_size);
    sendGenome = function(worker) {
      var genome;
      genome = db.next();
      if (genome != null) {
        worker.genome = genome;
        return worker.send(JSON.stringify({
          genome: genome
        }));
      } else {
        return wait(restart_delay)(function() {
          return sendGenome(worker);
        });
      }
    };
    runWorker = function() {
      var worker;
      worker = cluster.fork();
      return worker.on('message', function(msg) {
        msg = JSON.parse(msg);
        if ('hello' in msg) {
          sendGenome(worker);
        }
        if ('record' in msg) {
          db.record(msg.record);
        }
        if ('die' in msg) {
          return db.remove(worker.genome);
        }
      });
    };
    cluster.on("exit", function(worker, code, signal) {
      return wait(restart_delay)(function() {
        return runWorker();
      });
    });
    (function() {
      _results = [];
      for (var _j = 0; 0 <= nb_cores ? _j <= nb_cores : _j >= nb_cores; 0 <= nb_cores ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this).map(function(i) {
      return runWorker();
    });
    repeat(sampling_delay, function() {
      var g;
      g = db.pick();
      if (!g) {
        return;
      }
      console.log("random individual:");
      console.log("  hash:     : " + g.hash);
      console.log("  generation: " + g.generation);
      console.log("   parent stats:");
      console.log("    forking   : " + g.stats.forking_rate);
      console.log("    mutation  : " + g.stats.mutation_rate);
      console.log("    lifespan  : " + g.stats.lifespan_rate + "\n");
      console.log(" general stats:");
      console.log("  db size: " + (db.size()));
      return console.log("  counter: " + db.counter);
    });
    return console.log("  oldest : " + (db.oldestGeneration()) + "\n");
  };

}).call(this);
