// Generated by CoffeeScript 1.6.3
(function() {
  var NB_CORES, P, after, clone, copy, crypto, deck, distance, every, fs, inspect, isArray, isBoolean, isFunction, isNumber, isString, isUndefined, isValidNumber, log, makeId, natural, normalize, os, pick, pretty, prettyCode, randInt, readFile, round, round2, round3, sha1, shuffle, toStr;

  inspect = require('util').inspect;

  crypto = require('crypto');

  os = require('os');

  fs = require('fs');

  deck = require('deck');

  natural = require('natural');

  clone = require('node-v8-clone').clone;

  log = exports.log = console.log;

  normalize = exports.normalize = deck.normalize;

  distance = exports.distance = function(a, b) {
    if (isString(a) && isString(b)) {
      return 1.0 - natural.JaroWinklerDistance(a, b);
    } else {
      console.log("dist(" + a + "," + b + ")");
      a = Number(a);
      b = Number(b);
      return Math.abs(Math.log(b) - Math.log(a));
    }
  };

  every = exports.every = function(ft) {
    return setInterval.apply(null, ft);
  };

  after = exports.after = function(ft) {
    return setTimeout.apply(null, ft);
  };

  Number.prototype.ms = function(f) {
    return [f, 1 * this];
  };

  Number.prototype.second = function(f) {
    return [f, 1000 * this];
  };

  Number.prototype.seconds = function(f) {
    return [f, 1000 * this];
  };

  Number.prototype.sec = function(f) {
    return [f, 1000 * this];
  };

  Number.prototype.minute = function(f) {
    return [f, 60000 * this];
  };

  Number.prototype.minutes = function(f) {
    return [f, 60000 * this];
  };

  Number.prototype.min = function(f) {
    return [f, 60000 * this];
  };

  Number.prototype.hour = function(f) {
    return [f, 86400000 * this];
  };

  Number.prototype.hours = function(f) {
    return [f, 86400000 * this];
  };

  Number.prototype.day = function(f) {
    return [f, 86400000 * this];
  };

  Number.prototype.days = function(f) {
    return [f, 86400000 * this];
  };

  makeId = exports.makeId = function() {
    return Number("" + (new Date().valueOf()) + (Math.round(Math.random() * 10000)));
  };

  copy = exports.copy = function(a) {
    return clone(a, true);
  };

  P = exports.P = function(p) {
    if (p == null) {
      p = 0.5;
    }
    return +(Math.random() < p);
  };

  isFunction = exports.isFunction = function(obj) {
    return !!(obj && obj.constructor && obj.call && obj.apply);
  };

  isUndefined = exports.isUndefined = function(obj) {
    return typeof obj === 'undefined';
  };

  isArray = exports.isArray = function(obj) {
    return Array.isArray(obj);
  };

  isString = exports.isString = function(obj) {
    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
  };

  isNumber = exports.isNumber = function(obj) {
    return (obj === +obj) || toString.call(obj) === '[object Number]';
  };

  isBoolean = exports.isBoolean = function(obj) {
    return obj === true || obj === false;
  };

  toStr = exports.toStr = function(func) {
    return func.toString();
  };

  round = exports.round = function(value, d) {
    var x;
    if (d == null) {
      d = 4;
    }
    x = Math.pow(10, d);
    return Math.round(value * x) / x;
  };

  randInt = exports.randInt = function(min, max) {
    if (isUndefined(max)) {
      return Math.round(Math.random() * min);
    } else {
      return Math.round(min + (Math.random() * (max - min)));
    }
  };

  round2 = exports.round2 = function(x) {
    return Math.round(x * 100) / 100;
  };

  round3 = exports.round3 = function(x) {
    return Math.round(x * 1000) / 1000;
  };

  sha1 = exports.sha1 = function(src) {
    var shasum;
    shasum = crypto.createHash('sha1');
    shasum.update(new Buffer("" + src));
    return shasum.digest('hex');
  };

  NB_CORES = exports.NB_CORES = (function() {
    var cpus;
    cpus = Math.round(os.cpus().length);
    if (cpus < 3) {
      return 1;
    } else {
      return cpus - 2;
    }
  })();

  pick = exports.pick = deck.pick;

  shuffle = exports.shuffle = deck.shuffle;

  pretty = exports.pretty = function(obj) {
    return "" + (inspect(obj, false, 20, true));
  };

  prettyCode = exports.prettyCode = function(code) {
    var line, lines, str;
    lines = (function() {
      var _i, _len, _ref, _results;
      _ref = code[0].toString().split('\n');
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        _results.push(line.trim());
      }
      return _results;
    })();
    str = lines.slice(1, lines.length - 1).join('');
    if (str === '') {
      str = '[native code]';
    }
    return pretty([str].concat(code.slice(1)));
  };

  readFile = exports.readFile = function(input) {
    return fs.readFileSync(input, "utf8");
  };

  isValidNumber = exports.isValidNumber = function(value) {
    return (value != null) && !isNaN(value) && isFinite(value);
  };

}).call(this);
