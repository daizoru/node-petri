// Generated by CoffeeScript 1.4.0
(function() {
  var Database, Master, NB_CORES, P, Stats, Stream, cluster, debug, inspect, isFunction, makeId, pretty, repeat, timmy, wait, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  inspect = require('util').inspect;

  cluster = require('cluster');

  Stream = require('stream');

  _ref = require('ragtime'), repeat = _ref.repeat, wait = _ref.wait;

  timmy = require('timmy');

  Database = require('./database');

  Stats = require('./stats');

  _ref1 = require('./common'), P = _ref1.P, isFunction = _ref1.isFunction, makeId = _ref1.makeId, NB_CORES = _ref1.NB_CORES, pretty = _ref1.pretty;

  debug = function(msg) {
    if (true) {
      return console.log("" + msg);
    }
  };

  Master = (function(_super) {

    __extends(Master, _super);

    function Master(options) {
      var agent, agentConfigurator, bootstrap, database, databaseSize, debugInterval, emit, i, log, logLevel, maxGenerations, nbGenerations, onExit, onFork, onMsg, restart_delay, spawn, stopIfEmpty, workersByMachine, _i, _len, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.each = __bind(this.each, this);

      this.min = __bind(this.min, this);

      this.max = __bind(this.max, this);

      this.reduce = __bind(this.reduce, this);

      this.agents = __bind(this.agents, this);

      this.remove = __bind(this.remove, this);

      this.add = __bind(this.add, this);

      this.size = __bind(this.size, this);

      console.log("master started with options: " + pretty(options));
      workersByMachine = this.workersByMachine = (_ref2 = options.workersByMachine) != null ? _ref2 : NB_CORES;
      databaseSize = this.databaseSize = (_ref3 = options.databaseSize) != null ? _ref3 : 10;
      debugInterval = this.debugInterval = (_ref4 = options.debugInterval) != null ? _ref4 : 2..sec;
      maxGenerations = this.maxGenerations = (_ref5 = options.maxGenerations) != null ? _ref5 : Infinity;
      logLevel = this.logLevel = (_ref6 = options.logLevel) != null ? _ref6 : 0;
      stopIfEmpty = this.stopIfEmpty = (_ref7 = options.stopIfEmpty) != null ? _ref7 : true;
      onFork = (_ref8 = options.onFork) != null ? _ref8 : function() {};
      onMsg = (_ref9 = options.onMsg) != null ? _ref9 : function() {};
      onExit = (_ref10 = options.onExit) != null ? _ref10 : function() {};
      agentConfigurator = (_ref11 = options.config) != null ? _ref11 : function() {
        return {};
      };
      restart_delay = 500..ms;
      nbGenerations = 0;
      this.isMaster = true;
      database = this.database = new Database(databaseSize);
      bootstrap = (_ref12 = options.bootstrap) != null ? _ref12 : [];
      emit = function(key, msg) {
        return _this.emit(key, msg);
      };
      log = function(msg) {
        return console.log("MASTER: " + msg);
      };
      log("loading " + bootstrap.length + " agents");
      for (_i = 0, _len = bootstrap.length; _i < _len; _i++) {
        agent = bootstrap[_i];
        database.add(agent);
      }
      spawn = function() {
        var send, worker, _j, _len1, _ref13;
        if (++nbGenerations > maxGenerations) {
          log("max generations reached, stopping system");
          _ref13 = cluster.workers;
          for (_j = 0, _len1 = _ref13.length; _j < _len1; _j++) {
            worker = _ref13[_j];
            worker.destroy();
          }
          process.exit(0);
        }
        worker = cluster.fork();
        send = function(msg) {
          return worker.send(JSON.stringify(msg));
        };
        return worker.on('message', function(msg) {
          var _base, _k, _len2, _ref14, _ref15;
          msg = JSON.parse(msg);
          emit('message', msg);
          if ('ready' in msg) {
            agent = database.next();
            if (agent != null) {
              log("spawning agent " + agent.id + " to #" + worker.id);
              worker.agent = agent;
              agent.name = ("" + agent.id).slice(-8);
              agent.config = agentConfigurator(agent);
              if ((_ref14 = (_base = agent.config).logLevel) == null) {
                _base.logLevel = logLevel != null ? logLevel : 0;
              }
              worker.agent = agent;
              send(agent);
            } else {
              if (stopIfEmpty) {
                log("no more agent to send, stopping system");
                _ref15 = cluster.workers;
                for (_k = 0, _len2 = _ref15.length; _k < _len2; _k++) {
                  worker = _ref15[_k];
                  worker.destroy();
                }
                process.exit(0);
              } else {
                log("waiting..");
              }
            }
          }
          if ('fork' in msg) {
            log("agent " + agent.id + " asking for fork");
            database.record(msg.fork);
            onFork({
              agent: agent,
              fork: msg.fork
            });
          }
          if ('msg' in msg) {
            return onMsg({
              agent: agent,
              msg: msg.msg
            });
          }
        });
      };
      cluster.on("exit", function(worker, code, signal) {
        log(("worker " + worker.id + " exited (agent " + worker.agent.id + "): ") + (code > 0 ? ("" + code).red : ("" + code).green));
        database.remove(worker.agent.id);
        onExit({
          agent: worker.agent,
          code: code,
          signal: signal
        });
        return spawn();
      });
      i = 0;
      while (i++ < workersByMachine) {
        spawn();
      }
      this.emit('ready');
    }

    Master.prototype.size = function() {
      return this.database.length;
    };

    Master.prototype.add = function(agent) {
      return this.database.add(agent);
    };

    Master.prototype.remove = function(agent) {
      return this.database.remove(agent);
    };

    Master.prototype.agents = function(property) {
      return this.database.agents(property);
    };

    Master.prototype.reduce = function(f) {
      return this.database.reduce(f);
    };

    Master.prototype.max = function(f) {
      return this.database.max(f);
    };

    Master.prototype.min = function(f) {
      return this.database.min(f);
    };

    Master.prototype.each = function(f) {
      return this.database.each(f);
    };

    return Master;

  })(Stream);

  module.exports = function(args) {
    return new Master(args);
  };

}).call(this);
