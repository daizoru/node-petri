// Generated by CoffeeScript 1.6.3
(function() {
  var Master, Stream, cluster, inspect, pretty, sha1, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  inspect = require('util').inspect;

  cluster = require('cluster');

  Stream = require('stream');

  _ref = require('./common'), pretty = _ref.pretty, sha1 = _ref.sha1;

  Master = (function(_super) {
    __extends(Master, _super);

    function Master(main) {
      var actions, callbacks, emit, log,
        _this = this;
      this.isMaster = true;
      emit = function(key, msg) {
        return _this.emit(key, msg);
      };
      log = function(msg) {
        return console.log("Petri (master): " + msg);
      };
      callbacks = {
        onReady: function() {},
        onExit: function() {},
        onData: function() {}
      };
      actions = {
        spawn: function() {
          var worker;
          console.log("debug: spawning..");
          worker = cluster.fork();
          return worker.on('message', function(raw) {
            var msg, reply;
            msg = JSON.parse(raw);
            switch (msg.cmd) {
              case 'ready':
                process.nextTick(function() {});
                return callbacks.onReady(function(conf) {
                  var packet;
                  console.log("debug: got config");
                  worker.src = conf.src;
                  packet = conf;
                  conf.cmd = 'spawn';
                  return worker.send(JSON.stringify(packet));
                });
              case 'ping':
                return console.log("debug: worker is still alive");
              default:
                reply = function(msg) {
                  return worker.send(JSON.stringify(msg));
                };
                return process.nextTick(function() {
                  return callbacks.onData(reply, worker.src, msg);
                });
            }
          });
        },
        broadcast: function(msg) {
          var id, _i, _len, _ref1, _results;
          console.log("debug: broadcasting..");
          _ref1 = cluster.workers;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            id = _ref1[_i];
            _results.push(cluster.workers[id].send(JSON.stringify(msg)));
          }
          return _results;
        }
      };
      cluster.on("exit", function(worker, code, signal) {
        log(("worker " + (sha1(worker.src)) + " exited: ") + (code > 0 ? ("" + code).red : ("" + code).green));
        return process.nextTick(function() {
          return callbacks.onExit({
            worker: worker,
            src: worker.src,
            code: code,
            signal: signal
          });
        });
      });
      main.apply({
        'on': function(event, cb) {
          switch (event) {
            case 'exit':
              return callbacks.onExit = cb;
            case 'data':
              return callbacks.onData = cb;
            case 'ready':
              return callbacks.onReady = cb;
          }
        },
        spawn: actions.spawn,
        broadcast: actions.broadcast
      });
    }

    return Master;

  })(Stream);

  module.exports = function(onReady) {
    return new Master(onReady);
  };

}).call(this);
