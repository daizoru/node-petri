// Generated by CoffeeScript 1.4.0
(function() {
  var Database, Master, NB_CORES, P, Stats, Stream, cluster, debug, inspect, isFunction, makeId, pretty, repeat, timmy, wait, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  inspect = require('util').inspect;

  cluster = require('cluster');

  Stream = require('stream');

  _ref = require('ragtime'), repeat = _ref.repeat, wait = _ref.wait;

  timmy = require('timmy');

  Database = require('./database');

  Stats = require('./stats');

  _ref1 = require('./common'), P = _ref1.P, isFunction = _ref1.isFunction, makeId = _ref1.makeId, NB_CORES = _ref1.NB_CORES;

  debug = function(msg) {
    if (true) {
      return console.log("" + msg);
    }
  };

  pretty = function(obj) {
    return "" + (inspect(obj, false, 20, true));
  };

  Master = (function(_super) {

    __extends(Master, _super);

    function Master(options) {
      var agent, bootstrap, database, databaseSize, debugInterval, decimationTrigger, emit, frequency, i, log, maxGenerations, nbGenerations, restart_delay, spawn, workersByMachine, _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
        _this = this;
      if (options == null) {
        options = {};
      }
      workersByMachine = (_ref2 = options.workersByMachine) != null ? _ref2 : NB_CORES;
      decimationTrigger = (_ref3 = options.decimationTrigger) != null ? _ref3 : 10;
      frequency = (_ref4 = options.frequency) != null ? _ref4 : 1000;
      databaseSize = (_ref5 = options.databaseSize) != null ? _ref5 : 10;
      debugInterval = (_ref6 = options.debugInterval) != null ? _ref6 : 2..sec;
      maxGenerations = (_ref7 = options.maxGenerations) != null ? _ref7 : Infinity;
      restart_delay = 500..ms;
      nbGenerations = 0;
      database = new Database(databaseSize);
      bootstrap = (_ref8 = options.bootstrap) != null ? _ref8 : [];
      emit = function(key, msg) {
        return _this.emit(key, msg);
      };
      log = function(msg) {
        return console.log("MASTER: " + msg);
      };
      log("loading " + bootstrap.length + " agents");
      for (_i = 0, _len = bootstrap.length; _i < _len; _i++) {
        agent = bootstrap[_i];
        database.add(agent);
      }
      spawn = function() {
        var send, worker, _j, _len1, _ref9;
        if (++nbGenerations > maxGenerations) {
          log("max generations reached, stopping system");
          _ref9 = cluster.workers;
          for (_j = 0, _len1 = _ref9.length; _j < _len1; _j++) {
            worker = _ref9[_j];
            worker.destroy();
          }
          process.exit(0);
        }
        worker = cluster.fork();
        send = function(msg) {
          return worker.send(JSON.stringify(msg));
        };
        return worker.on('message', function(msg) {
          var _k, _len2, _ref10;
          msg = JSON.parse(msg);
          emit('message', msg);
          if ('ready' in msg) {
            agent = database.next();
            if (agent != null) {
              worker.agent = agent;
              return send(agent);
            } else {
              log("no more agent to send, stopping system");
              _ref10 = cluster.workers;
              for (_k = 0, _len2 = _ref10.length; _k < _len2; _k++) {
                worker = _ref10[_k];
                worker.destroy();
              }
              return process.exit(0);
            }
          } else if ('fork' in msg) {
            log("agent want to fork");
            return database.record(msg.fork);
          } else if ('die' in msg) {
            log("agent want to die: " + msg.die);
            return database.remove(worker.agent);
          }
        });
      };
      cluster.on("exit", function(worker, code, signal) {
        return wait(restart_delay)(function() {
          return spawn();
        });
      });
      i = 0;
      while (i++ < workersByMachine) {
        spawn();
      }
      this.emit('ready');
      repeat(debugInterval, function() {
        var g, genome;
        g = genome = database.pick();
        if (!g) {
          return;
        }
        return;
        log("random individual:");
        log("  hash:     : " + g.hash);
        log("  generation: " + g.generation);
        /*
              console.log "   parent stats:"
              console.log "    forking   : #{g.stats.forking_rate}"
              console.log "    mutation  : #{g.stats.mutation_rate}"
              console.log "    lifespan  : #{g.stats.lifespan_rate}\n"
        */

        log(" general stats:");
        log("  db size: " + (database.size()));
        log("  counter: " + database.counter);
        return log("  oldest : " + (database.oldestGeneration()) + "\n");
      });
    }

    return Master;

  })(Stream);

  module.exports = function(args) {
    return new Master(args);
  };

}).call(this);
