// Generated by CoffeeScript 1.4.0
(function() {
  var Database, Master, NB_CORES, P, Stats, Stream, cluster, debug, inspect, isFunction, makeId, pretty, repeat, timmy, wait, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  inspect = require('util').inspect;

  cluster = require('cluster');

  Stream = require('stream');

  _ref = require('ragtime'), repeat = _ref.repeat, wait = _ref.wait;

  timmy = require('timmy');

  Database = require('./database');

  Stats = require('./stats');

  _ref1 = require('./common'), P = _ref1.P, isFunction = _ref1.isFunction, makeId = _ref1.makeId, NB_CORES = _ref1.NB_CORES;

  debug = function(msg) {
    if (true) {
      return console.log("" + msg);
    }
  };

  pretty = function(obj) {
    return "" + (inspect(obj, false, 20, true));
  };

  Master = (function(_super) {

    __extends(Master, _super);

    function Master(options) {
      var agent, agentConfigurator, bootstrap, database, databaseSize, debugInterval, decimationTrigger, emit, frequency, i, log, logLevel, maxGenerations, nbGenerations, restart_delay, spawn, stopIfEmpty, workersByMachine, _i, _len, _ref10, _ref11, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.min = __bind(this.min, this);

      this.max = __bind(this.max, this);

      this.reduce = __bind(this.reduce, this);

      this.remove = __bind(this.remove, this);

      this.add = __bind(this.add, this);

      this.size = __bind(this.size, this);

      this.onDie = __bind(this.onDie, this);

      this.onFork = __bind(this.onFork, this);

      this.onMsg = __bind(this.onMsg, this);

      workersByMachine = this.workersByMachine = (_ref2 = options.workersByMachine) != null ? _ref2 : NB_CORES;
      decimationTrigger = this.decimationTrigger = (_ref3 = options.decimationTrigger) != null ? _ref3 : 10;
      frequency = this.frequency = (_ref4 = options.frequency) != null ? _ref4 : 1000;
      databaseSize = this.databaseSize = (_ref5 = options.databaseSize) != null ? _ref5 : 10;
      debugInterval = this.debugInterval = (_ref6 = options.debugInterval) != null ? _ref6 : 2..sec;
      maxGenerations = this.maxGenerations = (_ref7 = options.maxGenerations) != null ? _ref7 : Infinity;
      logLevel = this.logLevel = (_ref8 = options.logLevel) != null ? _ref8 : 0;
      stopIfEmpty = this.stopIfEmpty = (_ref9 = options.stopIfEmpty) != null ? _ref9 : true;
      agentConfigurator = (_ref10 = options.config) != null ? _ref10 : function() {
        return {};
      };
      restart_delay = 500..ms;
      nbGenerations = 0;
      database = this.database = new Database(databaseSize);
      bootstrap = (_ref11 = options.bootstrap) != null ? _ref11 : [];
      emit = function(key, msg) {
        return _this.emit(key, msg);
      };
      log = function(msg) {
        return console.log("MASTER: " + msg);
      };
      log("loading " + bootstrap.length + " agents");
      for (_i = 0, _len = bootstrap.length; _i < _len; _i++) {
        agent = bootstrap[_i];
        database.add(agent);
      }
      spawn = function() {
        var send, worker, _j, _len1, _ref12;
        if (++nbGenerations > maxGenerations) {
          log("max generations reached, stopping system");
          _ref12 = cluster.workers;
          for (_j = 0, _len1 = _ref12.length; _j < _len1; _j++) {
            worker = _ref12[_j];
            worker.destroy();
          }
          process.exit(0);
        }
        worker = cluster.fork();
        send = function(msg) {
          return worker.send(JSON.stringify(msg));
        };
        return worker.on('message', function(msg) {
          var _base, _k, _len2, _ref13, _ref14;
          msg = JSON.parse(msg);
          emit('message', msg);
          if ('ready' in msg) {
            agent = database.next();
            if (agent != null) {
              worker.agent = agent;
              agent.name = ("" + agent.id).slice(-8);
              agent.config = agentConfigurator(agent);
              if ((_ref13 = (_base = agent.config).logLevel) == null) {
                _base.logLevel = logLevel != null ? logLevel : 0;
              }
              send(agent);
            } else {
              if (stopIfEmpty) {
                log("no more agent to send, stopping system");
                _ref14 = cluster.workers;
                for (_k = 0, _len2 = _ref14.length; _k < _len2; _k++) {
                  worker = _ref14[_k];
                  worker.destroy();
                }
                process.exit(0);
              } else {
                log("waiting..");
              }
            }
          }
          if ('fork' in msg) {
            if (_this.onFork(agent)) {
              log("fork authorized");
              database.record(msg.fork);
            } else {

            }
          }
          if ('die' in msg) {
            if (_this.onDie(agent)) {
              log("death granted");
              database.remove(worker.agent);
            } else {

            }
          }
          if ('msg' in msg) {
            return _this.onMsg(agent, msg.msg);
          }
        });
      };
      cluster.on("exit", function(worker, code, signal) {
        return wait(restart_delay)(function() {
          return spawn();
        });
      });
      i = 0;
      while (i++ < workersByMachine) {
        spawn();
      }
      this.emit('ready');
      repeat(debugInterval, function() {
        var g, genome;
        g = genome = database.pick();
        if (!g) {
          return;
        }
        return;
        log("random individual:");
        log("  hash:     : " + g.hash);
        log("  generation: " + g.generation);
        /*
              console.log "   parent stats:"
              console.log "    forking   : #{g.stats.forking_rate}"
              console.log "    mutation  : #{g.stats.mutation_rate}"
              console.log "    lifespan  : #{g.stats.lifespan_rate}\n"
        */

        log(" general stats:");
        log("  db size: " + (database.size()));
        log("  counter: " + database.counter);
        return log("  oldest : " + (database.oldestGeneration()) + "\n");
      });
    }

    Master.prototype.onMsg = function(agent, msg) {
      return console.log("agent " + agent.id + " want to transmit a message: " + msg.msg);
    };

    Master.prototype.onFork = function(agent) {
      console.log("agent want to fork");
      return true;
    };

    Master.prototype.onDie = function(agent) {
      console.log("agent " + agent.id + " want to die: " + msg.die);
      return true;
    };

    Master.prototype.size = function() {
      return this.database.length;
    };

    Master.prototype.add = function(agent) {
      return this.database.add(agent);
    };

    Master.prototype.remove = function(agent) {
      return this.database.remove(agent);
    };

    Master.prototype.reduce = function(f) {
      return this.database.reduce(f);
    };

    Master.prototype.max = function(f) {
      return this.database.max(f);
    };

    Master.prototype.min = function(f) {
      return this.database.min(f);
    };

    return Master;

  })(Stream);

  module.exports = function(args) {
    return new Master(args);
  };

}).call(this);
