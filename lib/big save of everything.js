// Generated by CoffeeScript 1.4.0
(function() {
  var P, cluster, deck, inspect, makeId, map, mutable, mutate, pick, sha1, timmy, wait, _ref, _ref1, _ref2;

  cluster = require('cluster');

  inspect = require('util').inspect;

  deck = require('deck');

  _ref = require('ragtime'), map = _ref.map, wait = _ref.wait;

  _ref1 = require('evolve'), mutable = _ref1.mutable, mutate = _ref1.mutate;

  timmy = require('timmy');

  _ref2 = require('../common'), P = _ref2.P, makeId = _ref2.makeId, sha1 = _ref2.sha1, pick = _ref2.pick;

  module.exports = function(options) {
    var inputs, iterations, malloc, max_iterations, memory, mget, mpick, mrindex, outputs, size, update_frequency, _ref3, _ref4, _ref5,
      _this = this;
    if (options == null) {
      options = {};
    }
    console.log("WORKER STARTED");
    outputs = function(msg) {
      return process.send(JSON.stringify(msg));
    };
    inputs = function(cb) {
      return process.on('message', function(msg) {
        return cb(JSON.parse(msg));
      });
    };
    size = (_ref3 = options.size) != null ? _ref3 : 10;
    max_iterations = (_ref4 = options.max_iterations) != null ? _ref4 : 2;
    update_frequency = (_ref5 = options.update_frequency) != null ? _ref5 : 1..sec;
    malloc = function(N, f) {
      var i, _i, _results;
      if (f == null) {
        f = function() {
          return 0;
        };
      }
      _results = [];
      for (i = _i = 0; 0 <= N ? _i < N : _i > N; i = 0 <= N ? ++_i : --_i) {
        _results.push({
          inputs: [],
          value: f()
        });
      }
      return _results;
    };
    memory = malloc(size, function() {
      return 0.0;
    });
    mpick = function() {
      return pick(memory);
    };
    mget = function(i) {
      return memory[i];
    };
    mrindex = function() {
      return Math.round(Math.random() * (memory.length - 1));
    };
    iterations = 0;
    ({
      update: function() {
        var i, input, input_signal, n, _i, _j, _len, _len1, _ref6;
        console.log("computing..");
        for (_i = 0, _len = memory.length; _i < _len; _i++) {
          n = memory[_i];
          console.log("computing element");
          if (P(mutable(0.20))) {
            console.log("adding a new input");
            n.inputs.push(mutable({
              input: mrandindex(),
              weight: Math.random() * 0.01 + 1.0
            }));
          }
          if (n.inputs.length) {
            if (P(mutable(0.40))) {
              console.log("deleting a random input");
              n.inputs.splice(Math.round(Math.random() * n.inputs.length), 1);
            }
            if (P(mutable(0.30))) {
              console.log("updating an input weight");
              input = n.inputs[(n.inputs.length - 1) * Math.random()];
              input.weight = mutable(input.weight * 1.0);
            }
            if (P(mutable(0.95))) {
              console.log("computing local state");
              n.value = 0;
              _ref6 = n.inputs;
              for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
                i = _ref6[_j];
                input_signal = mget(i.input).value;
                n.value += mutable(input_signal * i.weight);
              }
              if (n.inputs.length > 0) {
                n.value = n.value / n.inputs.length;
              }
            }
          }
        }
        console.log("iteration " + (++iterations) + " completed.");
        if (iterations >= max_iterations) {
          console.log("stats: ");
          console.log("  " + memory.length + " in memory");
          console.log("  " + iterations + " iterations");
        } else {
          return wait(update_frequency)(function() {
            return compute();
          });
        }
      }
    });
    console.log("sending hello world");
    outputs({
      hello: 'world'
    });
    inputs(function(msg) {
      var err, foo, forking_rate, genome, lifespan_rate, mutation_rate;
      console.log("master sent us " + (inspect(msg)));
      genome = msg.genome;
      if (genome != null) {
        mutation_rate = 0.05;
        forking_rate = 0.60;
        lifespan_rate = 0.01;
        foo = 0.25;
        eval(genome.src);
        update();
        mutation_rate = Math.abs(mutation_rate);
        lifespan_rate = Math.abs(lifespan_rate);
        forking_rate = Math.abs(forking_rate);
        if (genome.generation > 0 && Math.random() < lifespan_rate) {
          outputs({
            die: "end of tree"
          });
        }
        if (Math.random() < forking_rate) {
          return evolve.clone({
            ratio: mutation_rate,
            src: genome.src,
            onComplete: function(new_src) {
              outputs({
                record: {
                  id: makeId(),
                  generation: genome.generation + 1,
                  hash: sha1(new_src),
                  src: new_src,
                  stats: {
                    mutation_rate: mutation_rate,
                    lifespan_rate: lifespan_rate,
                    forking_rate: forking_rate
                  }
                }
              });
              return process.exit(0);
            }
          });
        } else {
          return process.exit(0);
        }
      } else {
        err = "error, unknow message: " + (inspect(msg));
        console.log(err);
        return process.exit(1);
      }
    });
    return {
      start: function() {
        var environment, frequency, sync, _;
        frequency = _this.frequency;
        environment = _this.environment;
        sync = function(f) {
          return wait(_this.frequency)(function() {
            _this.stats.update();
            return f();
          });
        };
        iterations = 0;
        return (_ = function() {
          return sync(function() {
            var agent;
            iterations += 1;
            debug("iteration #" + iterations + ": " + _this.agents.length + " agents remaining");
            _this.agents = (function() {
              var _i, _len, _ref6, _results;
              _ref6 = this.agents;
              _results = [];
              for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
                agent = _ref6[_i];
                debug("preparing input data");
                inputs = environment.input({}, agent);
                debug("running update function on inputs: " + pretty(inputs));
                outputs = {};
                try {
                  outputs = agent.update(inputs);
                } catch (e1) {
                  debug("killing agent (bad update function: " + e1 + ")");
                  continue;
                }
                try {
                  environment.output(this.stats, {}, agent, outputs);
                } catch (e2) {
                  debug("killing agent (bad output: " + e2 + ")");
                  continue;
                }
                _results.push(agent);
              }
              return _results;
            }).call(_this);
            return _();
          });
        })();
      },
      decimate: function() {
        var agent, data, k, stats, v, _agents, _ref6, _ref7, _ref8, _ref9;
        debug("stats: " + (inspect(_this.stats)));
        _this.frequency = (_ref6 = options.frequency) != null ? _ref6 : 1000;
        stats = (_ref7 = options.stats) != null ? _ref7 : {
          energy: function(agent) {
            return agent.energy;
          }
        };
        _this.nbWorkers = (_ref8 = options.workersByMachine) != null ? _ref8 : common.NB_CORES;
        _this.decimationTrigger = (_ref9 = options.decimationTrigger) != null ? _ref9 : 10;
        _this.agents = [];
        if (options.agents != null) {
          _agents = options.agents;
          if (isFunction(_agents)) {
            _agents = _agents();
          }
          _this.agents = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = _agents.length; _i < _len; _i++) {
              agent = _agents[_i];
              data = {
                update: function() {}
              };
              for (k in agent) {
                v = agent[k];
                if (k === 'update') {
                  data.update = isFunction(v) ? v : eval(v);
                } else {
                  data[k] = v;
                }
              }
              _results.push(data);
            }
            return _results;
          })();
        }
        return _this.stats = new Stats(_this, stats);
      },
      start: function() {
        var environment, frequency, sync, _;
        frequency = _this.frequency;
        environment = _this.environment;
        sync = function(f) {
          return wait(_this.frequency)(function() {
            _this.stats.update();
            return f();
          });
        };
        iterations = 0;
        return (_ = function() {
          return sync(function() {
            var agent;
            iterations += 1;
            debug("iteration #" + iterations + ": " + _this.agents.length + " agents remaining");
            _this.agents = (function() {
              var _i, _len, _ref6, _results;
              _ref6 = this.agents;
              _results = [];
              for (_i = 0, _len = _ref6.length; _i < _len; _i++) {
                agent = _ref6[_i];
                debug("preparing input data");
                inputs = environment.input({}, agent);
                debug("running update function on inputs: " + pretty(inputs));
                outputs = {};
                try {
                  outputs = agent.update(inputs);
                } catch (e1) {
                  debug("killing agent (bad update function: " + e1 + ")");
                  continue;
                }
                try {
                  environment.output(this.stats, {}, agent, outputs);
                } catch (e2) {
                  debug("killing agent (bad output: " + e2 + ")");
                  continue;
                }
                _results.push(agent);
              }
              return _results;
            }).call(_this);
            return _();
          });
        })();
      },
      decimate: function() {
        return debug("stats: " + (inspect(_this.stats)));
      }
    };
  };

}).call(this);
