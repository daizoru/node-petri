// Generated by CoffeeScript 1.4.0
(function() {
  var P, cluster, deck, inspect, makeId, map, mutable, mutate, pick, sha1, timmy, wait, _ref, _ref1, _ref2;

  cluster = require('cluster');

  inspect = require('util').inspect;

  deck = require('deck');

  _ref = require('ragtime'), map = _ref.map, wait = _ref.wait;

  _ref1 = require('evolve'), mutable = _ref1.mutable, mutate = _ref1.mutate;

  timmy = require('timmy');

  _ref2 = require('../common'), P = _ref2.P, makeId = _ref2.makeId, sha1 = _ref2.sha1, pick = _ref2.pick;

  module.exports = function(options) {
    var inputs, outputs;
    if (options == null) {
      options = {};
    }
    console.log("WORKER STARTED");
    outputs = function(msg) {
      return process.send(JSON.stringify(msg));
    };
    inputs = function(cb) {
      var i, iterations, max_iterations, memory, size, update_frequency, _i, _ref3, _ref4, _ref5;
      process.on('message', function(msg) {
        return cb(JSON.parse(msg));
      });
      size = (_ref3 = options.size) != null ? _ref3 : 10;
      max_iterations = (_ref4 = options.max_iterations) != null ? _ref4 : 2;
      update_frequency = (_ref5 = options.update_frequency) != null ? _ref5 : 1..sec;
      memory = [];
      for (i = _i = 0; 0 <= size ? _i < size : _i > size; i = 0 <= size ? ++_i : --_i) {
        memory.push({
          inputs: [],
          value: Math.random()
        });
      }
      memory = memory;
      iterations = 0;
      return {
        randomNode: function() {
          return pick(memory);
        },
        randomIndex: function() {
          return Math.round(Math.random() * (memory.length - 1));
        },
        randomInputRange: function() {
          var _j, _ref6, _results;
          return (function() {
            _results = [];
            for (var _j = 0, _ref6 = randomIndex(); 0 <= _ref6 ? _j < _ref6 : _j > _ref6; 0 <= _ref6 ? _j++ : _j--){ _results.push(_j); }
            return _results;
          }).apply(this);
        },
        compute: function() {
          var input, input_signal, n, _j, _k, _len, _len1, _ref6;
          console.log("computing..");
          for (_j = 0, _len = memory.length; _j < _len; _j++) {
            n = memory[_j];
            console.log("computing element");
            if (P(mutable(0.20))) {
              console.log("adding a new input");
              n.inputs.push(mutable({
                input: randomIndex(),
                weight: Math.random() * 0.01 + 1.0
              }));
            }
            if (n.inputs.length) {
              if (P(mutable(0.40))) {
                console.log("deleting a random input");
                n.inputs.splice(Math.round(Math.random() * n.inputs.length), 1);
              }
              if (P(mutable(0.30))) {
                console.log("updating an input weight");
                input = n.inputs[(n.inputs.length - 1) * Math.random()];
                input.weight = mutable(input.weight * 1.0);
              }
              if (P(mutable(0.95))) {
                console.log("computing local state");
                n.value = 0;
                _ref6 = n.inputs;
                for (_k = 0, _len1 = _ref6.length; _k < _len1; _k++) {
                  i = _ref6[_k];
                  input_signal = memory[i.input].value;
                  n.value += mutable(input_signal * i.weight);
                }
                if (n.inputs.length > 0) {
                  n.value = n.value / n.inputs.length;
                }
              }
            }
          }
          console.log("iteration " + (++iterations) + " completed.");
          if (iterations >= max_iterations) {
            console.log("stats: ");
            console.log("  " + memory.length + " in memory");
            console.log("  " + iterations + " iterations");
          } else {
            return wait(update_frequency)(function() {
              return compute();
            });
          }
        }
      };
    };
    console.log("sending hello world");
    outputs({
      hello: 'world'
    });
    return inputs(function(msg) {
      var err, foo, forking_rate, genome, lifespan_rate, mutation_rate;
      console.log("master sent us " + (inspect(msg)));
      genome = msg.genome;
      if (genome != null) {
        mutation_rate = 0.05;
        forking_rate = 0.60;
        lifespan_rate = 0.01;
        foo = 0.25;
        eval(genome.src);
        compute();
        mutation_rate = Math.abs(mutation_rate);
        lifespan_rate = Math.abs(lifespan_rate);
        forking_rate = Math.abs(forking_rate);
        if (genome.generation > 0 && Math.random() < lifespan_rate) {
          outputs({
            die: "end of tree"
          });
        }
        if (Math.random() < forking_rate) {
          return evolve.clone({
            ratio: mutation_rate,
            src: genome.src,
            onComplete: function(new_src) {
              outputs({
                record: {
                  src: new_src,
                  generation: genome.generation + 1,
                  id: makeId(),
                  hash: sha1(new_src),
                  stats: {
                    mutation_rate: mutation_rate,
                    lifespan_rate: lifespan_rate,
                    forking_rate: forking_rate
                  }
                }
              });
              return process.exit(0);
            }
          });
        } else {
          return process.exit(0);
        }
      } else {
        err = "error, unknow message: " + (inspect(msg));
        console.log(err);
        return process.exit(1);
      }
    });
  };

}).call(this);
