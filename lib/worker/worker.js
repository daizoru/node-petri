// Generated by CoffeeScript 1.4.0
(function() {
  var P, Worker, deck, inspect, map, mutable, mutate, timmy, wait, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  inspect = require('util').inspect;

  deck = require('deck');

  _ref = require('ragtime'), map = _ref.map, wait = _ref.wait;

  _ref1 = require('evolve'), mutable = _ref1.mutable, mutate = _ref1.mutate;

  timmy = require('timmy');

  P = require('../common').P;

  Worker = (function() {

    function Worker(options) {
      var i, memory, _i, _ref2, _ref3, _ref4, _ref5;
      if (options == null) {
        options = {};
      }
      this.start = __bind(this.start, this);

      this.size = (_ref2 = options.size) != null ? _ref2 : 10;
      this.max_iterations = (_ref3 = options.max_iterations) != null ? _ref3 : 2;
      this.update_frequency = (_ref4 = options.update_frequency) != null ? _ref4 : 1..sec;
      memory = [];
      for (i = _i = 0, _ref5 = this.size; 0 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 0 <= _ref5 ? ++_i : --_i) {
        memory.push({
          inputs: [],
          value: Math.random()
        });
      }
      this.memory = memory;
    }

    Worker.prototype.start = function() {
      var iterations, max_iterations, memory, update_frequency;
      update_frequency = this.update_frequency;
      max_iterations = this.max_iterations;
      memory = this.memory;
      iterations = 0;
      ({
        randomNode: function() {
          return deck.pick(memory);
        },
        randomIndex: function() {
          return Math.round(Math.random() * (memory.length - 1));
        },
        randomInputRange: function() {
          var _i, _ref2, _results;
          return (function() {
            _results = [];
            for (var _i = 0, _ref2 = randomIndex(); 0 <= _ref2 ? _i < _ref2 : _i > _ref2; 0 <= _ref2 ? _i++ : _i--){ _results.push(_i); }
            return _results;
          }).apply(this);
        },
        compute: function() {
          var i, input, input_signal, n, _i, _j, _len, _len1, _ref2;
          console.log("computing..");
          for (_i = 0, _len = memory.length; _i < _len; _i++) {
            n = memory[_i];
            console.log("computing element");
            if (P(mutable(0.20))) {
              console.log("adding a new input");
              n.inputs.push(mutable({
                input: randomIndex(),
                weight: Math.random() * 0.01 + 1.0
              }));
            }
            if (n.inputs.length) {
              if (P(mutable(0.40))) {
                console.log("deleting a random input");
                n.inputs.splice(Math.round(Math.random() * n.inputs.length), 1);
              }
              if (P(mutable(0.30))) {
                console.log("updating an input weight");
                input = n.inputs[(n.inputs.length - 1) * Math.random()];
                input.weight = mutable(input.weight * 1.0);
              }
              if (P(mutable(0.95))) {
                console.log("computing local state");
                n.value = 0;
                _ref2 = n.inputs;
                for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
                  i = _ref2[_j];
                  input_signal = memory[i.input].value;
                  n.value += mutable(input_signal * i.weight);
                }
                if (n.inputs.length > 0) {
                  n.value = n.value / n.inputs.length;
                }
              }
            }
          }
          console.log("iteration " + (++iterations) + " completed.");
          if (iterations >= max_iterations) {
            console.log("stats: ");
            console.log("  " + memory.length + " in memory");
            console.log("  " + iterations + " iterations");
          } else {
            return wait(update_frequency)(function() {
              return compute();
            });
          }
        }
      });
      return compute();
    };

    return Worker;

  })();

}).call(this);
